#pragma config(Sensor, port1, touch, sensorVexIQ_LED)
#pragma config(Sensor, port2, gyro, sensorVexIQ_Gyro)
#pragma config(Motor, motor2, motorB, tmotorNone, openLoop)
#pragma config(Motor, motor3, motorC, tmotorNone, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

task main()
{
    int FV = SensorValue[gyro];
    int degree;
    float distance;

    if (SensorValue[touch] == 1)
    {
        motor[motorB] = 0;
        motor[motorC] = 0;
        degree = (360 * 30) / 17.58;
        moveMotorTarget(motorB, degree, 30);
        moveMotorTarget(motorC, degree, 30);
        waitUntilMotorStop(motorB);
        waitUntilMotorStop(motorC);

        FV = SensorValue[gyro];

        while (SensorValue[gyro] <= 90 + FV)
        {
            writeDebugStreamLine("Gyro: %d", SensorValue[gyro]);
            motor[motorB] = 30;
            motor[motorC] = -30;
        }

        motor[motorB] = 0;
        motor[motorC] = 0;
        distance = 30 / sinDegrees(90);
        writeDebugStreamLine("distance = %fcm", distance);
        sleep(1000);
        degree = (360 * distance) / 17.58;
        moveMotorTarget(motorB, degree, 30);
        moveMotorTarget(motorC, degree, 30);
        waitUntilMotorStop(motorB);
        waitUntilMotorStop(motorC);

        FV = SensorValue[gyro];

        while (SensorValue[gyro] <= 150 + FV)
        {
            writeDebugStreamLine("Gyro: %d", SensorValue[gyro]);
            motor[motorB] = 30;
            motor[motorC] = 0;
        }

        motor[motorB] = 0;
        motor[motorC] = 0;
        distance = 30 / cosDegrees(60);
        writeDebugStreamLine("distance = %fcm", distance);
        sleep(1000);
        degree = (360 * distance) / 17.58;
        moveMotorTarget(motorB, degree, 30);
        moveMotorTarget(motorC, degree, 30);
        waitUntilMotorStop(motorB);
        waitUntilMotorStop(motorC);
    }
}
